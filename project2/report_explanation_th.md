# คำอธิบายรายงานโปรเจกต์ 2 (ฉบับเข้าใจง่าย)

ไฟล์นี้จะอธิบายเนื้อหาในไฟล์ `template-project2.tex` ที่เราตอบไป ด้วยภาษาที่ง่ายที่สุด เพื่อให้คุณเข้าใจแนวคิดเบื้องหลังแต่ละส่วนอย่างละเอียด เหมือนเริ่มเรียนใหม่ไปพร้อมกันเลยครับ

---

## Section 1: Bayes filter

ส่วนนี้คือหัวใจของโปรเจกต์ เป็นการอธิบาย "สมอง" ที่เราจะสร้างให้ Pac-Man เพื่อใช้คาดเดาตำแหน่งของผีที่ล่องหนอยู่ เราจะแบ่งสมองออกเป็น 2 ส่วนหลักๆ คือ "แบบจำลองเซ็นเซอร์" (มันแปลผลข้อมูลที่วัดมายังไง) และ "แบบจำลองการเคลื่อนที่" (มันคาดเดาการเดินของผียังไง)

### 1.a - แบบจำลองเซ็นเซอร์ (Sensor Model)

**เป้าหมาย:** อธิบายด้วยคณิตศาสตร์ว่า "เซ็นเซอร์วัดระยะ" ของ Pac-Man ทำงานอย่างไร

**แนวคิดหลัก:**
เซ็นเซอร์ของเรามัน "เก่า" และ "ขึ้นสนิม" มันเลยวัดระยะทางได้ไม่เป๊ะ 100% ค่าที่วัดได้จะมีการบวกลบความคลาดเคลื่อน (noise) เข้าไปเสมอ หน้าที่ของเราคือสร้างสมการที่บอกว่า "ถ้าผีอยู่ที่ตำแหน่ง A จริงๆ ความน่าจะเป็นที่เซ็นเซอร์จะวัดระยะทางออกมาเป็นค่า B คือเท่าไหร่?"

**มาดูสมการกันทีละส่วน:**

1.  **สมการพื้นฐาน:**
    `ระยะทางที่วัดได้ (Evidence)` = `ระยะทางจริง` + `Noise`

    *   `E_t`: คือ "ระยะทางที่วัดได้" ที่เซ็นเซอร์บอกเราจริงๆ
    *   `d(X_t, X_p)`: คือ "ระยะทางจริง" (Manhattan Distance) ระหว่างตำแหน่งจริงของผี (`X_t`) กับตำแหน่งของ Pac-Man (`X_p`)

2.  **Noise มาจากไหน?:**
    โปรเจกต์นี้จำลอง Noise โดยใช้สิ่งที่เรียกว่า **"การแจกแจงแบบทวินาม" (Binomial Distribution)**

    *   **เปรียบเทียบง่ายๆ:** การแจกแจงแบบทวินามเหมือนกับการ "โยนเหรียญ" ครับ สมมติเราโยนเหรียญ `n` ครั้ง (เช่น 100 ครั้ง) โดยที่โอกาสออกหัวคือ `p` (เช่น 0.5) การแจกแจงนี้จะบอกความน่าจะเป็นที่เราจะโยนได้หัวทั้งหมด `K` ครั้ง
    *   ในโปรเจกต์นี้ `noise` ถูกสร้างมาจาก `K - np` โดยที่ `K` คือผลลัพธ์จากการสุ่มแบบทวินาม การลบด้วย `np` ทำให้ค่าเฉลี่ยของ noise อยู่ที่ 0 (คือส่วนใหญ่มักจะไม่คลาดเคลื่อน แต่ก็มีโอกาสคลาดเคลื่อนได้)

3.  **ประกอบร่างเป็นสมการสุดท้าย:**
    เราต้องการหา `P(E_t | X_t)` หรือ "ความน่าจะเป็นที่จะวัดได้ค่า `E_t` เมื่อผีอยู่ที่ `X_t`"

    *   จากสมการแรก เราย้ายข้างเพื่อหาค่า `K` ที่ทำให้เกิด `E_t` นั้นๆ:
        `K = E_t - d(X_t, X_p) + np`

    *   ดังนั้น ความน่าจะเป็นที่เราต้องการ ก็คือความน่าจะเป็นที่จะสุ่มได้ค่า `K` นี้จากการแจกแจงแบบทวินามนั่นเอง!
        `P(E_t | X_t) = binom.pmf(k = ..., n, p)`

**สรุปง่ายๆ:** แบบจำลองเซ็นเซอร์คือฟังก์ชันที่บอกว่า "ถ้าผีอยู่ห่างจากเราจริงๆ 5 ช่อง ความน่าจะเป็นที่เซ็นเซอร์จะวัดได้ 4, 5, หรือ 6 ช่อง คือเท่าไหร่" โดยค่าที่ใกล้เคียงความจริงที่สุด (5 ช่อง) จะมีความน่าจะเป็นสูงสุด และค่าที่ห่างออกไปจะมีความน่าจะเป็นลดหลั่นกันไปตามกราฟของการแจกแจงแบบทวินาม

---

### 1.b - แบบจำลองการเคลื่อนที่ (Transition Model)

**เป้าหมาย:** สร้างสมการคณิตศาสตร์สมการเดียวที่อธิบายพฤติกรรมการเดินของผีได้ทั้ง 3 แบบ (`confused`, `afraid`, `scared`)

**แนวคิดหลัก:**
ผีแต่ละตัว "กลัว" Pac-Man ไม่เท่ากัน ทำให้มันตัดสินใจเดินหนีแตกต่างกัน เราจะสร้างแบบจำลองที่ใช้ "ตัวแปร" แค่ตัวเดียวเพื่อปรับระดับความกลัวนี้

**มาดูสมการกันทีละส่วน:**

1.  **เป้าหมายของสมการ:**
    เราต้องการหา `P(X_{t+1} | X_t)` หรือ "ความน่าจะเป็นที่ผีจะเดินไปที่ช่อง `X_{t+1}` ในตาหน้า ถ้าตอนนี้มันอยู่ที่ช่อง `X_t`"

2.  **หัวใจของแบบจำลอง: "แฟกเตอร์ความกลัว" (Fear Factor, k_f)**
    เราจะสมมติตัวแปรชื่อ `k_f` ขึ้นมาเพื่อเป็นตัวแทนระดับความกลัวของผี

3.  **การให้คะแนนแต่ละตาเดิน (Weight):**
    สำหรับทุกทิศทางที่ผีสามารถเดินไปได้ (ซ้าย, ขวา, หน้า, หลัง) เราจะให้ "คะแนน" หรือ "น้ำหนัก" (weight) กับทิศทางนั้นๆ

    *   **ถ้า** การเดินไปในทิศทางนั้น ทำให้ผี **อยู่ไกลจาก Pac-Man มากขึ้น** (หรือเท่าเดิม) -> เราจะให้คะแนนสูงเท่ากับ `k_f`
    *   **ถ้า** การเดินไปในทิศทางนั้น ทำให้ผี **เข้าใกล้ Pac-Man มากขึ้น** -> เราจะให้คะแนนแค่ `1`

4.  **เปลี่ยนคะแนนเป็นความน่าจะเป็น:**
    เมื่อเราได้คะแนนของทุกทิศทางแล้ว เราก็แค่แปลงมันเป็นความน่าจะเป็นโดยการ "ทำให้เป็นบรรทัดฐาน" (Normalize)
    `ความน่าจะเป็นของทิศทาง A` = `คะแนนของทิศทาง A` / `ผลรวมคะแนนของทุกทิศทาง`

**การเชื่อมโยงกับผีแต่ละประเภท:**

*   **ผี `confused` (สับสน):** เราตั้งค่า `k_f = 1`
    *   ผลลัพธ์: ไม่ว่าจะเดินเข้าใกล้หรือไกลออกไป ก็ได้คะแนน `1` เท่ากันหมด ทำให้ผีเดินแบบสุ่มๆ ไปในทุกทิศทางที่ไปได้

*   **ผี `afraid` (กลัว):** เราตั้งค่า `k_f = 2`
    *   ผลลัพธ์: ทิศทางที่เดินหนี Pac-Man จะมีโอกาสถูกเลือกมากกว่าทิศทางที่เดินเข้าหาถึง 2 เท่า

*   **ผี `scared` (กลัวมาก):** เราตั้งค่า `k_f = 8`
    *   ผลลัพธ์: ทิศทางที่เดินหนี Pac-Man จะมีโอกาสถูกเลือกมากกว่าถึง 8 เท่า! ทำให้ผีตัวนี้พยายามหนีอย่างสุดชีวิตและคาดเดาพฤติกรรมได้ง่ายกว่า

**สรุปง่ายๆ:** แบบจำลองการเคลื่อนที่คือสมการที่บอกว่า "ผีจะเลือกเดินไปทางไหน" โดยให้น้ำหนักกับทางที่หนี Pac-Man ได้ดีกว่า ซึ่งระดับการให้น้ำหนักนี้จะถูกควบคุมโดย "แฟกเตอร์ความกลัว" `k_f` นั่นเองครับ

---

## Section 3: Experiment (การทดลอง)

หลังจากเราสร้าง "สมอง" (Bayes Filter) เสร็จแล้ว ส่วนนี้คือการทดสอบว่าสมองของเราทำงานได้ดีแค่ไหน และมีปัจจัยอะไรที่ส่งผลต่อประสิทธิภาพของมันบ้าง

### 3.a & 3.b - ตัวชี้วัดประสิทธิภาพ

เราจะวัดความเก่งของ "สมอง" เราด้วยค่า 2 อย่างหลักๆ ที่เราเขียนโค้ดเพิ่มใน `_record_metrics`:

*   **ความไม่แน่นอน (Uncertainty):** เราวัดด้วยค่า **เอนโทรปี (Entropy)**
    *   **เปรียบเทียบง่ายๆ:** ถ้าแผนที่ความเชื่อของเราเบลอๆ ไปทั่วทุกช่อง แสดงว่าเรา "ไม่มั่นใจเลย" -> ค่า Entropy จะสูง
    *   ถ้าแผนที่ความเชื่อของเรามีจุดสว่างชัดๆ แค่ไม่กี่จุด แสดงว่าเรา "มั่นใจมาก" -> ค่า Entropy จะต่ำ

*   **ความแม่นยำ (Quality):** เราวัดด้วย **ระยะห่างที่ผิดพลาด (Error Distance)**
    *   **เปรียบเทียบง่ายๆ:** คือระยะห่างระหว่าง "จุดที่เราคิดว่าผีน่าจะอยู่ที่สุด" กับ "ตำแหน่งจริงของผี"
    *   ถ้าค่านี้น้อย (เช่น 0 หรือ 1) แสดงว่าเราทายได้แม่นมาก

### 3.c - การรันการทดลองและสร้างกราฟ

เราได้สร้างสคริปต์ `run_experiments.py` เพื่อทำการทดลองทั้งหมดโดยอัตโนมัติ และสร้างกราฟ 4 รูปให้เรา ซึ่งแสดงให้เห็นว่าค่า Entropy และ Error Distance เปลี่ยนแปลงไปอย่างไรเมื่อเวลาผ่านไป สำหรับผีแต่ละชนิดและในแต่ละด่าน

### 3.d - อภิปรายผลของพฤติกรรมผี

นี่คือการ "อ่าน" กราฟที่เราได้มา เพื่อดูว่านิสัยของผีส่งผลต่อการค้นหาของเราอย่างไร

*   **ประเด็นหลัก:** ผีที่พฤติกรรม **คาดเดาง่าย** (`scared` ที่หนีอย่างเดียว) จะทำให้เราหาตำแหน่งเจอได้เร็วและแม่นยำกว่ามาก สังเกตได้จากเส้นกราฟของ `scared` (สีน้ำเงิน) ที่ลดลงต่ำและเร็วกว่าเพื่อน
*   ในทางกลับกัน ผีที่พฤติกรรม **คาดเดายาก** (`confused` ที่เดินมั่ว) จะทำให้เราไม่ค่อยมั่นใจในตำแหน่งของมัน กราฟ Entropy และ Error จึงสูงอยู่ตลอด
*   **ผลของด่าน:** ด่านที่มีกำแพงเยอะ (`large_filter_walls`) จะช่วย "จำกัด" ทางเดินของผี ทำให้แม้แต่ผีที่เดินมั่วก็ยังคาดเดาได้ง่ายขึ้นเล็กน้อย สังเกตได้ว่ากราฟในด่านนี้โดยรวมแล้วจะต่ำกว่าด่านโล่งๆ

### 3.e - อภิปรายผลของความรวนของเซ็นเซอร์

นี่คือการวิเคราะห์ว่าถ้าเซ็นเซอร์ของเรา "ดีขึ้น" หรือ "แย่ลง" จะเกิดอะไรขึ้น

*   **ประเด็นหลัก:** ความแม่นยำของเซ็นเซอร์ (ควบคุมด้วย `sensorvariance`) ส่งผลโดยตรงต่อคุณภาพของฟิลเตอร์
    *   ถ้า **variance ต่ำ** (เซ็นเซอร์แม่นมาก): ข้อมูลที่ได้จะน่าเชื่อถือมาก ทำให้ฟิลเตอร์ของเรา "มั่นใจ" และ "แม่นยำ" ได้อย่างรวดเร็ว (กราฟจะลดลงเร็วและต่ำ)
    *   ถ้า **variance สูง** (เซ็นเซอร์รวนมาก): ข้อมูลที่ได้จะเชื่อถือได้น้อย ทำให้ฟิลเตอร์ต้องใช้เวลานานมากกว่าจะมั่นใจในตำแหน่งของผี (กราฟจะลดลงช้าและอาจไม่ต่ำเท่าเดิม)

### 3.f & 3.g - การสร้าง Pac-Man อัตโนมัติ (ส่วนโบนัส)

*   **แนวคิด (3.f):** เราจะสร้าง Pac-Man ที่เดินไปกินผีเองได้อย่างไร?
    *   **วิธีที่ง่ายที่สุด (Greedy):** ในทุกๆ เทิร์น ให้ดูแผนที่ความเชื่อ (Belief State) แล้วหาว่า "จุดไหนที่น่าจะมีผีอยู่มากที่สุด" จากนั้นก็เลือกเดินไปในทิศทางที่ทำให้เข้าใกล้จุดนั้นมากที่สุด

*   **การนำไปใช้ (3.g):** ไฟล์ `pacmanagent.py` ที่คุณทำ คือการนำแนวคิด Greedy จากข้อ 3.f มาเขียนเป็นโค้ดจริงนั่นเอง!
    *   **ปัญหาที่เจอ (เดินวน):** ที่คุณเห็นว่ามันเดินวนไปมา เป็นเพราะกลยุทธ์แบบ Greedy มัน "สายตาสั้น" คือมองแค่ก้าวถัดไปที่ดีที่สุด โดยไม่ได้วางแผนเส้นทางระยะยาว ทำให้มันอาจจะติดอยู่หน้ากำแพงได้ง่ายๆ

---

ตอนนี้คุณมีทั้งโค้ดที่ทำงานได้, ผลการทดลอง, รายงาน, และไฟล์อธิบายฉบับสมบูรณ์แล้วครับ!