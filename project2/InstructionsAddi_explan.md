# คำอธิบายเพิ่มเติมสำหรับคำแนะนำ (Instructions) ของโปรเจกต์ 2

ไฟล์นี้จะอธิบายรายละเอียดของแต่ละข้อในส่วน "Instructions" ของ `README.md` ด้วยภาษาที่เข้าใจง่ายขึ้น เพื่อให้เห็นภาพรวมว่าต้องทำอะไรบ้างในแต่ละขั้นตอน ทั้งในส่วนของการเขียนรายงานและการทดลองครับ

---

## ภาพรวมของโปรเจกต์

**สถานการณ์:** Pac-Man ยิงเลเซอร์ใส่ผี ทำให้พวกมัน **ล่องหน** แต่ยัง **กินได้** อยู่ ปัญหาคือ Pac-Man ไม่รู้ว่าผีที่ล่องหนอยู่ตรงไหน! โชคดีที่เขามี "เซ็นเซอร์" ที่คอยบอก "ระยะห่าง" จากตัวเขาไปยังผี แต่เซ็นเซอร์นี้เก่ามาก (rusty) เลยให้ค่าที่คลาดเคลื่อน (มี noise)

**เป้าหมายของคุณ:** สร้าง "สมอง" ให้ Pac-Man โดยใช้อัลกอริทึม **Bayes Filter** เพื่อประมวลผลข้อมูลจากเซ็นเซอร์ และ "คาดเดา" ว่าผีแต่ละตัวน่าจะอยู่ที่ตำแหน่งไหนมากที่สุดในเขาวงกต ผลลัพธ์ที่ได้คือ "แผนที่ความน่าจะเป็น" หรือที่เรียกว่า **Belief State**

---

## 1. ส่วนของทฤษฎี Bayes Filter (สำหรับเขียนในรายงาน `report.pdf`)

ส่วนนี้เป็นการตอบคำถามเชิงทฤษฎีและคณิตศาสตร์ ไม่ต้องเขียนโค้ด แต่ต้องทำความเข้าใจโค้ดที่มีอยู่เพื่อนำมาอธิบาย

### ข้อ 1.a - อธิบาย Sensor Model

*   **ให้ทำอะไร?:** ให้คุณไปดูโค้ดในฟังก์ชัน `_get_evidence` (ในไฟล์ `bayesfilter.py`) ซึ่งเป็นตัวจำลองการทำงานของเซ็นเซอร์ แล้วให้อธิบายการทำงานของมันออกมาในรูปของ **สมการคณิตศาสตร์**
*   **แนวทาง:** ฟังก์ชันนั้นใช้ `binom.rvs` ซึ่งเกี่ยวข้องกับการแจกแจงแบบทวินาม (Binomial Distribution) เพื่อสร้าง noise ขึ้นมา หน้าที่ของคุณคือเขียนสมการสำหรับ **P(E<sub>t</sub> | X<sub>t</sub>)** ออกมาให้ได้
    *   **E<sub>t</sub>** คือ ค่าระยะทางที่เซ็นเซอร์วัดได้ (Evidence) ณ เวลา t
    *   **X<sub>t</sub>** คือ ตำแหน่งจริงของผี (State) ณ เวลา t
    *   สมการนี้จะบอกว่า "ถ้าผีอยู่ที่ตำแหน่ง X<sub>t</sub> จริงๆ ความน่าจะเป็นที่จะวัดระยะทาง E<sub>t</sub> ได้ คือเท่าไหร่"

### ข้อ 1.b - อธิบาย Transition Model

*   **ให้ทำอะไร?:** ผีในเกมมี 3 ประเภท (`scared`, `afraid`, `confused`) ซึ่งแต่ละตัว "กลัว" Pac-Man ไม่เท่ากัน ทำให้พฤติกรรมการหนีต่างกันเล็กน้อย ให้คุณไปดูโค้ดพฤติกรรมของผีในไฟล์ `/pacman_module/ghostAgents.py` (ฟังก์ชัน `getDistribution`) แล้วสร้าง **แบบจำลองการเคลื่อนที่ (Transition Model)** ที่เป็น **สมการคณิตศาสตร์เพียงสมการเดียว** ที่สามารถอธิบายพฤติกรรมของผีได้ทั้ง 3 แบบ
*   **แนวทาง:** แบบจำลองของคุณควรจะมี "พารามิเตอร์" (ตัวแปร) แค่ตัวเดียว ที่ใช้ปรับระดับ "ความขี้กลัว" ของผีได้ เช่น อาจจะตั้งชื่อพารามิเตอร์ว่า `k` (fear factor)
    *   ถ้า `k` มีค่าน้อย ผีอาจจะเดินมั่วๆ (แบบ `confused`)
    *   ถ้า `k` มีค่ามาก ผีจะพยายามเดินไปในทิศทางที่ไกลจาก Pac-Man มากขึ้น (แบบ `scared`)
    *   สมการของคุณคือ **P(X<sub>t+1</sub> | X<sub>t</sub>)** ซึ่งบอกว่า "ถ้าผีอยู่ที่ตำแหน่ง X<sub>t</sub> ในตอนนี้ ความน่าจะเป็นที่มันจะเดินไปที่ตำแหน่ง X<sub>t+1</sub> ในตาถัดไปคือเท่าไหร่"

---

## 2. ส่วนของการเขียนโค้ด (ที่เราทำไปแล้ว)

### ข้อ 2.a - เขียนโค้ด Bayes Filter

*   **ให้ทำอะไร?:** นำทฤษฎีจากข้อ 1 มาเขียนเป็นโค้ดจริงในไฟล์ `bayesfilter.py` ซึ่งเราได้ทำไปแล้วในขั้นตอนก่อนหน้านี้ โดยแบ่งเป็น 3 ฟังก์ชันหลัก:
    1.  `_get_sensor_model`: เขียนโค้ดตามสมการจากข้อ 1.a
    2.  `_get_transition_model`: เขียนโค้ดตามสมการจากข้อ 1.b
    3.  `_get_updated_belief`: เป็นหัวใจหลัก! ที่จะเรียกใช้ 2 ฟังก์ชันข้างบนเพื่อคำนวณ Belief State ใหม่ในทุกๆ เทิร์น ตามหลักการของ Bayes Filter

---

## 3. ส่วนของการทดลองและวิเคราะห์ผล (สำหรับเขียนในรายงาน `report.pdf`)

ส่วนนี้คือการนำโค้ดที่เขียนเสร็จแล้วไปรันเพื่อเก็บข้อมูล, สร้างกราฟ, และวิเคราะห์ผล

### ข้อ 3.a - สร้างตัวชี้วัด "ความไม่แน่นอน"

*   **ให้ทำอะไร?:** คิดหาวิธีวัดว่าตอนนี้ Pac-Man "ไม่มั่นใจ" แค่ไหนว่าผีอยู่ไหน แล้วเขียนโค้ดสำหรับคำนวณค่านี้ในฟังก์ชัน `_record_metrics`
*   **แนวทาง:** ตัวอย่างที่นิยมใช้คือ **เอนโทรปี (Entropy)** ของ Belief State
    *   ถ้า Belief State กระจายไปทั่วแผนที่ (ความน่าจะเป็นเท่าๆ กันทุกช่อง) แสดงว่าเราไม่มั่นใจเลย -> เอนโทรปีจะสูง
    *   ถ้า Belief State กระจุกตัวอยู่ที่ช่องเดียว (ความน่าจะเป็นสูงมากที่ช่องนั้น) แสดงว่าเรามั่นใจมาก -> เอนโทรปีจะต่ำ

### ข้อ 3.b - สร้างตัวชี้วัด "ความแม่นยำ"

*   **ให้ทำอะไร?:** คิดหาวิธีวัดว่า Belief State ของเรา "ทายถูก" แค่ไหน โดยเทียบกับตำแหน่งจริงของผี (ซึ่งตอนทดลองเราจะรู้ตำแหน่งจริง) แล้วเขียนโค้ดคำนวณใน `_record_metrics`
*   **แนวทาง:**
    *   **วิธีที่ 1:** คำนวณ "ระยะห่าง" (เช่น Manhattan Distance) ระหว่างตำแหน่งที่น่าจะเป็นที่สุดใน Belief State กับตำแหน่งจริงของผี ถ้าค่านี้น้อยแสดงว่าแม่นยำ
    *   **วิธีที่ 2:** ดูว่า Belief State ของเราให้ "ความน่าจะเป็น" ณ ตำแหน่งจริงของผีเท่าไหร่ ถ้าค่านี้สูงแสดงว่าแม่นยำ

### ข้อ 3.c - รันการทดลองและสร้างกราฟ

*   **ให้ทำอะไร?:** ทำการทดลองอย่างเป็นระบบ!
    1.  **รันเกม** ใน 2 ด่าน (`large_filter`, `large_filter_walls`) กับผีทั้ง 3 ชนิด (`scared`, `afraid`, `confused`)
    2.  ในแต่ละเกม ให้ **บันทึกค่า** ตัวชี้วัดจากข้อ 3.a และ 3.b ในทุกๆ เทิร์น
    3.  ทำซ้ำข้อ 1-2 **หลายๆ รอบ** (เช่น 10-20 รอบ) เพื่อให้ได้ข้อมูลที่น่าเชื่อถือ
    4.  นำผลลัพธ์มาหา **ค่าเฉลี่ย** และ **วาดกราฟ** โดยให้แกน X เป็นเวลา (Time Step) และแกน Y เป็นค่าตัวชี้วัด อย่าลืมใส่ **แถบความคลาดเคลื่อน (Error Bars)** ด้วย

### ข้อ 3.d & 3.e - อภิปรายผล

*   **ให้ทำอะไร?:** ดูผลจากกราฟในข้อ 3.c แล้วนำมาวิเคราะห์และอภิปรายในรายงาน
*   **ข้อ 3.d (ผลของพฤติกรรมผี):** พารามิเตอร์ "ความขี้กลัว" ของผีส่งผลต่อความแม่นยำในการหาตำแหน่งของเราอย่างไร? ผีที่ขี้กลัวมาก (เช่น `scared`) ทำให้เราหาเจอง่ายขึ้นหรือยากขึ้น? แล้วด่านที่มีกำแพงเยอะๆ ส่งผลต่างจากด่านโล่งๆ หรือไม่? เพราะอะไร?
*   **ข้อ 3.e (ผลของความรวนของเซ็นเซอร์):** ลองเปลี่ยนค่า `--sensorvariance` ตอนรันโปรแกรม (เช่น เพิ่มขึ้น, ลดลง) แล้วดูว่ามันส่งผลต่อกราฟอย่างไร เซ็นเซอร์ที่ "รวน" มากขึ้น (variance สูง) ทำให้เราหาตำแหน่งผียากขึ้นหรือไม่? เพราะอะไร?

### ข้อ 3.f & 3.g - การสร้าง Pac-Man อัตโนมัติ (ส่วนโบนัส)

*   **ข้อ 3.f (แนวคิด):** ถ้าจะให้ Pac-Man เดินไปกินผีเองโดยอัตโนมัติ โดยใช้แค่ Belief State ที่เราคำนวณได้ คุณจะออกแบบ "สมอง" ให้ Pac-Man อย่างไร? (อธิบายเป็นแนวคิดในรายงาน)
    *   **แนวทาง:** อาจจะให้มันเดินไปยังช่องที่มีความน่าจะเป็นเจอผีสูงสุด? หรือคำนวณ "ค่าคาดหวัง" ของการเดินในแต่ละทิศทาง?
*   **ข้อ 3.g (เขียนโค้ดโบนัส):** นำแนวคิดจากข้อ 3.f มาเขียนเป็นโค้ดจริงในไฟล์ `pacmanagent.py`

---

หวังว่าคำอธิบายนี้จะช่วยให้คุณเห็นภาพรวมของโปรเจกต์ชัดเจนขึ้นนะครับ!