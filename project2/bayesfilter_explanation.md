# เจาะลึก `bayesfilter.py`: สมองกลของ Pac-Man นักล่าผีล่องหน

ไฟล์ `bayesfilter.py` คือหัวใจสำคัญของโปรเจกต์นี้ มันคือ "สมอง" ที่ช่วยให้ Pac-Man สามารถรับมือกับความไม่แน่นอน (Uncertainty) และไล่ล่าผีที่มองไม่เห็นได้ เอกสารนี้จะอธิบายหลักการทำงานของมันอย่างละเอียด ตั้งแต่ทฤษฎีพื้นฐานไปจนถึงการนำไปใช้ในโค้ดแต่ละบรรทัด

---

## 1. ปัญหา: การติดตามเป้าหมายที่มองไม่เห็น

สถานการณ์ของเราคือ Pac-Man ไม่สามารถมองเห็นตำแหน่งของผีได้โดยตรง (`X_t`) สิ่งเดียวที่เขามีคือ "เซ็นเซอร์" ที่บอกระยะห่างโดยประมาณ (`E_t`) ซึ่งเป็นข้อมูลที่มีความคลาดเคลื่อน (noisy)

**เป้าหมายของเราคือ:** คำนวณ **"สถานะความเชื่อ" (Belief State)** ซึ่งก็คือการแจกแจงความน่าจะเป็น (Probability Distribution) ของตำแหน่งผี ณ เวลา `t` โดยอาศัยข้อมูลทั้งหมดที่เคยได้รับมา `e_{1:t}`

> **Belief State:** `Bel(X_t) = P(X_t | e_1, e_2, ..., e_t)`

พูดง่ายๆ ก็คือ เราต้องการสร้าง "แผนที่ความร้อน" ที่บอกว่า "ณ ตอนนี้ ผีน่าจะอยู่ที่ตำแหน่งไหนมากที่สุด"

---

## 2. หัวใจของ Bayes Filter: การอัปเดตความเชื่อแบบวนซ้ำ (Recursive State Estimation)

Bayes Filter ทำงานโดยการอัปเดตความเชื่อจากเวลา `t-1` ไปยังเวลา `t` อย่างต่อเนื่องในทุกๆ เทิร์น โดยอาศัยหลักการของทฤษฎีความน่าจะเป็นของเบย์ (Bayes' Theorem)

สมการหลักของ Bayes Filter คือ:

`P(X_t | e_{1:t}) ∝ P(e_t | X_t) * P(X_t | e_{1:t-1})`

สมการนี้อาจจะดูน่ากลัว แต่ถ้าเราแยกส่วนประกอบของมัน จะเข้าใจได้ง่ายขึ้นมาก การทำงานของมันแบ่งออกเป็น 2 ขั้นตอนหลักในทุกๆ เทิร์น:

1.  **การคาดการณ์ (Prediction):** "ถ้าเมื่อวานเราเชื่อว่าผีอยู่ที่นี่ วันนี้มันน่าจะเดินไปอยู่ที่ไหน?"
2.  **การอัปเดต (Update):** "เมื่อเทียบกับสิ่งที่เซ็นเซอร์บอกเราวันนี้ ความเชื่อที่เราคาดการณ์ไว้นั้นควรจะปรับแก้อย่างไร?"

เรามาเจาะลึกแต่ละขั้นตอนกันครับ

---

## 3. ขั้นตอนที่ 1: การคาดการณ์ (Prediction) - "ผีจะเดินไปไหนต่อ?"

ในขั้นตอนนี้ เราจะใช้ความเชื่อจากเทิร์นที่แล้ว (`Bel(X_{t-1})`) เพื่อคาดการณ์ความเชื่อในเทิร์นปัจจุบัน **ก่อนที่จะได้รับข้อมูลจากเซ็นเซอร์**

**เป้าหมาย:** คำนวณ `P(X_t | e_{1:t-1})`

เราทำสิ่งนี้โดยพิจารณาการเคลื่อนที่ที่เป็นไปได้ทั้งหมดของผีจากทุกตำแหน่งที่มันอาจจะเคยอยู่ เราใช้ **"แบบจำลองการเคลื่อนที่" (Transition Model)** ซึ่งบอกความน่าจะเป็นที่ผีจะย้ายจากตำแหน่งหนึ่งไปยังอีกตำแหน่งหนึ่ง: `P(X_t | X_{t-1})`

สมการทางคณิตศาสตร์คือ:

`P(X_t | e_{1:t-1}) = Σ_{x_{t-1}} P(X_t | x_{t-1}) * P(x_{t-1} | e_{1:t-1})`

*   `P(X_t | x_{t-1})`: ความน่าจะเป็นที่ผีจะไปที่ `X_t` ถ้าเทิร์นที่แล้วอยู่ที่ `x_{t-1}` (จาก Transition Model)
*   `P(x_{t-1} | e_{1:t-1})`: ความเชื่อของเราเกี่ยวกับตำแหน่งของผีในเทิร์นที่แล้ว

### การนำไปใช้ในโค้ด:

1.  **`_get_transition_model(pacman_position)`:**
    *   ฟังก์ชันนี้จะสร้างเมทริกซ์ 4 มิติ `(w1, h1, w2, h2)` ที่เก็บค่า `P(X_t=(w1,h1) | X_{t-1}=(w2,h2))`
    *   มันทำงานโดยการวนลูปไปในทุกๆ ช่อง (`w2`, `h2`) ที่เป็นไปได้
    *   สำหรับแต่ละช่อง มันจะหาทางเดินที่ถูกกฎหมาย (ซ้าย, ขวา, หน้า, หลัง)
    *   จากนั้นมันจะให้ "น้ำหนัก" (weight) กับแต่ละทางเดินโดยใช้ `fear_factor`
        *   ถ้าเดินแล้ว **หนีห่าง** จาก Pac-Man -> น้ำหนัก = `fear_factor` (เช่น 8 สำหรับ `scared`)
        *   ถ้าเดินแล้ว **เข้าใกล้** Pac-Man -> น้ำหนัก = `1`
    *   สุดท้าย มันจะแปลงน้ำหนักเหล่านี้ให้เป็นความน่าจะเป็น (Normalize) เพื่อให้ผลรวมของทุกทิศทางเป็น 1

2.  **`_get_updated_belief(...)` (ส่วน Prediction):**
    ```python
    # predicted_belief = Σ_{x_{t-1}} P(X_t|x_{t-1}) * P(x_{t-1}|e_{1:t-1})
    predicted_belief = np.einsum(
        'klwh,wh->kl', transition_model, prev_belief)
    ```
    *   `prev_belief` คือ `P(x_{t-1} | e_{1:t-1})`
    *   `transition_model` คือ `P(X_t | x_{t-1})`
    *   `np.einsum` เป็นวิธีที่ทรงพลังในการคูณและบวกเมทริกซ์ ในที่นี้มันกำลังทำการคูณเมทริกซ์ตามสมการข้างบนเพื่อคำนวณ `predicted_belief` หรือ `P(X_t | e_{1:t-1})`

**ผลลัพธ์ของขั้นตอนนี้:** เราจะได้แผนที่ความเชื่อที่ "เบลอ" หรือ "กระจายตัว" ออกไปจากเทิร์นที่แล้ว เพราะผีอาจจะเดินไปได้หลายทิศทาง

---

## 4. ขั้นตอนที่ 2: การอัปเดต (Update) - "เซ็นเซอร์บอกอะไรเรา?"

หลังจากที่เราคาดการณ์ตำแหน่งคร่าวๆ แล้ว ก็ถึงเวลาใช้ข้อมูลล่าสุดจากเซ็นเซอร์ (`e_t`) เพื่อ "ปรับแก้" และ "ทำให้คมชัด" ขึ้น

**เป้าหมาย:** คำนวณ `P(X_t | e_{1:t})` จาก `predicted_belief`

เราทำสิ่งนี้โดยใช้ **"แบบจำลองเซ็นเซอร์" (Sensor Model)** ซึ่งบอกความน่าจะเป็นที่เราจะวัดค่า `e_t` ได้ ถ้าผีอยู่ที่ตำแหน่ง `X_t` จริงๆ: `P(e_t | X_t)`

สมการทางคณิตศาสตร์คือ:

`P(X_t | e_{1:t}) ∝ P(e_t | X_t) * P(X_t | e_{1:t-1})`

*   `P(e_t | X_t)`: ความน่าจะเป็นที่จะวัดระยะทาง `e_t` ได้ ถ้าผีอยู่ที่ `X_t` (จาก Sensor Model)
*   `P(X_t | e_{1:t-1})`: คือ `predicted_belief` ที่เราคำนวณไว้ในขั้นตอนที่ 1

### การนำไปใช้ในโค้ด:

1.  **`_get_sensor_model(pacman_position, evidence)`:**
    *   ฟังก์ชันนี้จะสร้างเมทริกซ์ 2 มิติ ที่เก็บค่า `P(E_t=evidence | X_t=(w,h))`
    *   มันทำงานโดยการวนลูปไปในทุกๆ ช่อง (`w`, `h`) ที่เป็นไปได้
    *   สำหรับแต่ละช่อง มันจะคำนวณ "ระยะทางจริง" (Manhattan Distance) จากช่องนั้นไปยัง Pac-Man
    *   จากนั้น มันจะใช้ `binom.pmf` (ฟังก์ชันมวลความน่าจะเป็นของการแจกแจงแบบทวินาม) เพื่อคำนวณความน่าจะเป็นที่เซ็นเซอร์จะวัดได้ค่า `evidence` ถ้าผีอยู่ที่ช่องนั้นจริงๆ โดยพิจารณาถึง noise ที่เป็นไปได้
    *   ผลลัพธ์คือแผนที่ "Likelihood" ที่บอกว่า "ตำแหน่งไหนบ้างที่สอดคล้องกับค่าที่เซ็นเซอร์วัดได้"

2.  **`_get_updated_belief(...)` (ส่วน Update):**
    ```python
    # updated_belief ∝ P(e_t|X_t) * P(X_t|e_{1:t-1})
    sensor_model = self._get_sensor_model(pacman_position, evidence)
    updated_belief_unnormalized = sensor_model * predicted_belief
    ```
    *   `sensor_model` คือ `P(e_t | X_t)`
    *   `predicted_belief` คือ `P(X_t | e_{1:t-1})`
    *   การคูณแบบ element-wise (`*`) คือการนำความน่าจะเป็นของแต่ละช่องมาคูณกันตามสมการของเบย์

**ผลลัพธ์ของขั้นตอนนี้:** เราจะได้แผนที่ความเชื่อที่ยังไม่ได้ปรับสเกล (`unnormalized`) ซึ่งตำแหน่งที่ทั้ง `predicted_belief` และ `sensor_model` ให้ค่าสูง จะมีค่าสูงขึ้นไปอีก ในขณะที่ตำแหน่งที่ไม่สอดคล้องกันจะมีค่าลดลง

---

## 5. ขั้นตอนสุดท้าย: การทำให้เป็นบรรทัดฐาน (Normalization)

หลังจากคูณกันในขั้นตอนที่ 2 ผลรวมของความน่าจะเป็นในแผนที่ของเราจะไม่เท่ากับ 1 อีกต่อไป ขั้นตอนสุดท้ายจึงเป็นการปรับสเกลทุกค่าในแผนที่เพื่อให้ผลรวมกลับมาเป็น 1 อีกครั้ง

### การนำไปใช้ในโค้ด:

```python
# _get_updated_belief(...)
s = np.sum(updated_belief_unnormalized)
if s < 1e-9:
    # Handle cases where evidence is impossible, reset to uniform
    ...
else:
    updated_belief = updated_belief_unnormalized / s

new_beliefs.append(updated_belief)
```
*   เราแค่หาผลรวมของทุกค่าใน `updated_belief_unnormalized` แล้วนำค่านั้นไปหารทุกช่อง
*   `updated_belief` ที่ได้นี้คือ `Bel(X_t)` ที่สมบูรณ์ ซึ่งจะถูกใช้เป็น `prev_belief` ในการคำนวณเทิร์นถัดไป

---

## บทสรุป: วงจรแห่งความเชื่อ

การทำงานของ `bayesfilter.py` คือวงจรที่ไม่สิ้นสุด (จนกว่าจะกินผีได้):

1.  **เริ่มต้น:** มีความเชื่อเก่า (`Bel(X_{t-1})`)
2.  **คาดการณ์ (Predict):** ใช้ `_get_transition_model` เพื่อคำนวณว่าผีน่าจะเดินไปไหน (`predicted_belief`) ทำให้ความเชื่อ "เบลอ" ออก
3.  **รับข้อมูลใหม่ (Observe):** ได้รับค่า `evidence` จากเซ็นเซอร์
4.  **อัปเดต (Update):** ใช้ `_get_sensor_model` เพื่อสร้างแผนที่ Likelihood แล้วนำไปคูณกับ `predicted_belief` เพื่อ "ปรับแก้" ความเชื่อ
5.  **ปรับสเกล (Normalize):** ทำให้ผลรวมความน่าจะเป็นกลับมาเป็น 1 ได้เป็นความเชื่อใหม่ (`Bel(X_t)`)
6.  **วนกลับไปข้อ 1** โดยใช้ความเชื่อใหม่เป็นจุดเริ่มต้นสำหรับเทิร์นถัดไป

ด้วยวงจรนี้ แม้ Pac-Man จะมองไม่เห็นผี แต่เขาก็สามารถสร้างและปรับปรุง "แผนที่ในใจ" ของเขาได้อย่างต่อเนื่อง ทำให้เขาสามารถ "เห็น" ตำแหน่งที่น่าจะเป็นที่สุดของผีและไล่ล่ามันได้อย่างมีประสิทธิภาพ


```

<!--
[PROMPT_SUGGESTION]อธิบายการทำงานของไฟล์ pacmanagent.py หน่อย ว่าทำไมบางครั้งมันถึงเดินติดกำแพง[/PROMPT_SUGGESTION]
[PROMPT_SUGGESTION]ในไฟล์ bayesfilter.py ส่วนของ transition model ทำงานอย่างไร[/PROMPT_SUGGESTION]
